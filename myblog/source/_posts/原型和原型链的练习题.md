No1:

```javascript
function fun(){
    this.a=0;
    this.b=function(){
        alert(this.a);
    }
}
fun.prototype={
    b:function(){
        this.a=20;
        alert(this.a);
    },
    c:function(){
        this.a=30;
        alert(this.a)
    }
}
var my_fun=new fun();
my_fun.b();
my_fun.c();
```

输出结果：alert弹出0    alert弹出30   

答题思路：

```javascript
1.fun---函数---堆内存
	“代码字符串”
    prototype（函数都天生自带一个prototype属性，属性值是个对象---堆内存）----A
2.func.prototype------每一个原型对象都有一个constructor函数----B
  	constructor：fun
    __proto__
3.fun.prototype={
    ...   //类原型重定向-----见下面详细解析
    /*--------------------新创建对象(堆) C,然后A指向C-----------------------
    	b:function(){}
    	c:function(){}
    	__proto__ ---------->  指向Object.prototype
    */
  }
/*---------------------------------类原型重定向--------------------------
  a.重新定向的对象中没有constructor;
  b.原始的原型对象上存放的属性方法不会存储到新重定向的对象上，因此实例不能再用原始的方法;
  c.原始的原型对象不被占用，堆内存释放;
  d.内置类的原型对象不允许重定向;
*/
4.var my_fun=new fun(); ----创建实例，并把函数执行【按照普通函数执行，且this指向实例】
  	a:0
    b:function(){...}
    __proto__  ------------>  C
5.my_fun.b() ———— b为私有，this指向my_fun,所以alert输出'0'
6.my_fun.c() ———— c为原型上的方法，this指向my_fun,所以alert输出'30'                   
```



向内置的原型上扩展方法：

```javascript
function Func(){
    
}

//方法太多时，一个个处理比较麻烦;
Func.prototype.A = function(){};
Func.prototype.B = function(){};
...
```



一般想往原型上批量设置属性方法，都是基于***重定向***方式，存在的问题：

- 缺失了constructor；
- 缺失了原始原型对象上的属性和方法；

```javascript
//重定向
Func.prototype = {
    A:function(){},
    B:function(){}
}
```



**解决批量扩展问题的方法**：

- 手动设置constructor

  ```
  Func.prototype = {
  	constructor:Func,
  	A:function(){},
      B:function(){}
  }
  ```

- 两个原型对象合并，用新的原型对象替换原始的原型对象（问题：如果新老属性方法相同，新值会替换旧值）

  ```javascript
  Func.prototype.test = function(){}  //原有的
  Func.prototype = Object.assign(Func.prototype,{
      A:function(){},
      B:function(){}
  })
  
  let f = new Func;
  console.log(f)
  ```

- 把老的原型对象作为新原型对象的上级原型（推荐使用）

  ```javascript
  let newProto = Object.create(Func.prototype);   //创建空对象，原型链指向老对象Func.prototype
  newProto = Object.assign(newProto,{
      A:function(){},
      B:function(){}
  })
  Func.prototype = newProto;
  ```

No2:

```javascript
function C1(name) {
    if (name) {
        this.name = name;
    }
}
function C2(name) {
    this.name = name;
}
function C3(name) {
    this.name = name || 'join';
}
C1.prototype.name = 'Tom';
C2.prototype.name = 'Tom';
C3.prototype.name = 'Tom';
alert((new C1().name) + (new C2().name) + (new C3().name));
```

输出结果：'Tomundefinedjoin'

答题思路：

```javascript
1.C1,C2,C3各开辟堆内存A1/A2/A3，有自己的prototype，并指向堆内存B1/B2/B3，堆内存B中有各自的constructor函数
2.B1,B2,B3都新增了name属性，value为'Tom'
3.new C1().name  =>  if判断没有执行，没有设置私有属性，找原型 => 'Tom'
4.new C2().name  =>  执行this.name=name=undefined => 'undefined'
5.new C3().name  =>  执行this.name=name=undefined || 'join' = 'join'
6.输出'Tomundefinedjoin'
```

No3:

```javascript
function Fn() {
    let a = 1;
    this.a = a;
}
Fn.prototype.say = function () {
    this.a = 2;
}
Fn.prototype = new Fn;
let f1 = new Fn;

Fn.prototype.b = function () {
    this.a = 3;
};
console.log(f1.a);
console.log(f1.prototype);
console.log(f1.b);
console.log(f1.hasOwnProperty('b'));
console.log('b' in f1);
console.log(f1.constructor == Fn);
```

输出结果：1    undefined    f(){this.a=3}    false   true   true

答题思路：

```javascript
1.Fn---函数---堆内存
	“代码字符串”
     prototype属性-------对象 【一开始指向A,执行完3指向B,此时B指向A】
2.prototype对象--堆内存---A
	constructor:Fn
	say:function(){...}
	__proto__  ------> Object.prototype
3.Fn.prototype = new Fn;   【原型重定向】
  new Fn---堆---B：
  	a:1【let为私有变量，this.xxx才是私有属性】
    b:function(){...} -----------【执行完5后新增】
	__proto__  ---->  Fn.prototype
4.let f1 = new Fn;   创建实例f1
  f1---堆内存---C
  	a:1
	__proto__  ----> 指向B
5.B中新增b属性
6.console.log(f1.a);  =>  this指向f1,f1.a = 1;   //1
  console.log(f1.prototype);  => 对象无该属性，只有函数有该属性  //undefined
  console.log(f1.b); => b不是f1私有的，__proto__向上查找  // f(){this.a = 3}
  console.log(f1.hasOwnProperty('b'));    非私有   //false
  console.log('b' in f1); => 检测b是否为f1的属性，不论公有私有都可以检测到   //true
  console.log(f1.constructor == Fn);  => 向上查找，直到找到A中 //true
```

No4:

```javascript
function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
}

Foo.getName = function () {
    console.log(2);
};

Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
function getName() {
    console.log(5);
}
Foo.getName();  
getName();  
Foo().getName();  
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
```

输出结果：2  4  1  1   2   3   3

答题思路：

```javascript
/*****************************考察点：函数的三种角色 & 运算符优先级********************************/

1.变量提升：
  function Foo(){...} ------ 堆 AF1 ---- 原型指向等一系列操作
  	Foo类---AF1:
    	“代码字符串”
        prototype ----> A
        getName:function(){console.log(2)}   ------【2.2执行新增该属性】
    Foo.prototype---A:
    	constructor:Foo
         getName:function () {console.log(3);}    -------【2.3执行新增该属性】
         __proto__   ----->  Object.prototype
  var getName;
  function getName(){...} ----- 堆 AF2(输出5的函数) ---- 原型指向等一系列操作
  	getName---AF2:
         “代码字符串”
         prototype -----> B
    getName.prototype---B:
         constructor:getName
         __proto__  -----> Object.prototype
   => 执行完2.4之后全局getName-----堆 AF3(输出4的函数)
2.代码执行：
  2.1 function Foo(){...}   //不处理
  2.2 Foo.getName = function () {console.log(2);}   //把Foo当作普通对象，新增getName属性
  2.3 Foo.prototype.getName = function () {console.log(3);}  //作为构造函数：原型上设置实例调取的公有方法
  2.4 var getName = function () {console.log(4);}   //全局getName由AF2---> AF3(输出4的函数)
  2.5 function getName() {console.log(5);}   //不处理
                 
  Foo.getName();  //Foo对象，访问对象成员   => 2
  getName();   //全局getName执行  =>  4    
  /*var和function不存在谁优先级高低问题，按照变量提升处理即可。
    比如var a=2;function a(){};
    变量提升：var a;function a(){}------------X
    代码执行：a=2;
  */
  Foo().getName();   //把Foo当作普通函数执行，执行返回结果调用getName => Foo执行，getName不是私有变量，找全局，于是把全局getName变为输出函数1的函数 => this指向window => 1
  getName();   //此时，全局getName为输出1的函数  => 执行全局getName => 1
            
/*--------------运算符优先级------------------
    成员访问 obj.xxx------19    
    带参数列表new    new Fn() ------ 19
    不带参数列表new   new Fn --------18
    相同优先级，从左到右运算;不同优先级，优先级大的先执行;
*/            
 //【new：当作普通函数执行，创建实例】
 new Foo.getName();   //先Foo.getName(),后new => 2
 new Foo().getName();  //先new Foo(),后getName() => 3
 new new Foo().getName();  //先let a = new Foo(),再a.getName(),最后new a => 3
```

No5:

```javascript
let n = 10;
let m = n.plus(10).minus(5);
console.log(m);  //=>15（10+10-5）
```

答题：

```javascript
考察原型重写：需要在原型上扩展一个plus实现相加功能和minus实现相减功能;
/*
 * 向内置类原型扩展方法：
 * 1.可以直接让实例调用，而此时方法执行，方法中的this是调用的实例（调取比较方便）;
 * 2.注意：我们自己扩展的方法不要覆盖内置的方法（最好设置的方法带个前缀）;
 * 3.可以实现链式写法：上一个方法执行返回的结果，可以继续调取本结果所属类原型上的方法;
 */

在Number上扩展了方法,this指向创建的实例n
Number.prototype.plus = function plus(arg){
    //this永远是对象数据类型的值（除了null和undefined）
    //对象+数字-----不一定都是字符串拼接
    return  this + arg; 
}

Number.prototype.minus = function minus(arg){
    return this - arg;
}

let n = 10;
console.log(n.plus(5))    //15
console.log(n.minus(3))   //7
console.log(n.plus(5).minus(3));  //12


function initParams(num){
    num = Number(num);
    return isNaN(num) ? 0 : num;
}
```

创建值有两种方式：字面量方式 和 构造函数

- 对于引用数据类型来讲，两种方式都是创建所属类的实例，并且都是对象数据类型的；
- 但是基本类型，两种方式创建出来的结果不一样。字面量方式创造的是基本类型的值，构造函数创建出来的是引用数据类型的值，但是都是Number类的一个实例（都可以调取Number.prototype原型上的方法）；
- Symbol / BigInt 不能被创建；

对象+数字：不一定都是字符串拼接；

对象本身是想转换为数字再进行运算的，对象转换为数字，并不是先toString()，需要先valueOf()获取原始值[[PrimitiveValue]]，如果有原始值（原始值是基本类型的值），直接基于原始值处理，没有原始值的

No6:

```javascript
/*
 * 编写queryURLParams方法实现如下的效果（至少两种方案）
 */
let url="http://www.zhufengpeixun.cn/?lx=1&from=wx#video";
console.log(url.queryURLParams("from")); //=>"wx"
console.log(url.queryURLParams("_HASH")); //=>"video"
```

答题：

```javascript
//方法一
String.prototype.queryURLParams = function queryURLParams(key){
    let obj = {};
    let {search,hash} = new URL(this);
    //处理HASH
    if(hash){
        obj['_HASH'] = hash.substring(1);
    }
    //处理PARAMS
    if(search){
        search = search.substring(1).split('&');
        search.forEach(item=>{
           let [key,value] = item.split('=');
           obj[key] = value;
        })
    }
    return key ? obj[key] : obj;
}


//方法二
String.prototype.queryURLParams = function queryURLParams(key){
    let obj = {}
    this.replace(/([^?=&#]+)=([^?=&#])/g,(_,key,value)=>obj[key] = value);
    this.replace(/#([^?=&#]+)/g,(_,hash)=>obj['_HASH'] = hash);
    return key ? obj[key] : obj;
}
```

No7：基于ES6中的class重构下面的代码

```javascript
function Modal(x,y){
    this.x=x;
    this.y=y;
}
Modal.prototype.z=10;
Modal.prototype.getX=function(){
    console.log(this.x);
}
Modal.prototype.getY=function(){
    console.log(this.y);
}
Modal.n=200;
Modal.setNumber=function(n){
    this.n=n;
};
let m = new Model(10,20);
```

答题：

```javascript
//考察ES6语法
class Modal{
    //构造函数
    constructor(x,y){
        //给实例设置的私有属性
        this.x = x;
        this.y = y;
    }
    //z = 10;   //ES7+给实例设置私有属性

	//-------------------给原型设置方法，但是不能设置属性---------------------------
    getX(){
        console.log(this.x);
    }
    getY(){
        console.log(this.y);
    }
   	
    //把Modal当作普通对象设置的键值对(静态属性方法)
    static n = 200;  //ES7+
    static setNumber(){
        this.n=n;
    }
}
Modal.prototype.z = 10;   //给原型设置属性

let m = new Model(10,20);
```

No8:

```javascript
let obj = {
    2: 3,
    3: 4,
    length: 2,
    push: Array.prototype.push
}
obj.push(1);
obj.push(2);
console.log(obj);
```

输出结果：{2:1,3:2,length:4,push:f(){...}}

答题思路：

```javascript
//主要考察Array.prototype.push的实现

很明显，push方法实现是下面的过程
Array.prototype.push = function A(val) {
　　　this[this.length] = val;
　　  // =>this.length 在原来的基础上加1
　　　return this.length;
}

obj.push(1); => this指向obj => obj[obj.length] => obj[2] = 1;   length:3
obj.push(2); => this指向obj => obj[obj.length] => obj[3] = 2;   length:4
console.log(obj);  //obj:{2:1,3:2,length:4,push:f(){...}}
```

No9：a等于什么值会让下面条件成立

```javascript
var a = ?;
if (a == 1 && a == 2 && a == 3) {
    console.log('OK');
}
```

答题：

```javascript
/*
 * == 比较，如果两边数据类型不一致，默认会进行数据类型转换
 *   解决方案1：对象转换伟数字，需要调取valueOf/toString(如果对象私有属性中有toString,则不会在向原型上去查找)
 */

//方案1：借助对象转换为数字需要先转换为字符串，重写toString方法
var a = {
	i:0,
	toString(){
        //this -> a
	    return ++this.i;
	}
}

//方案2：重写数组.join方法为shift方法，拿到每次shift的值
let a = [1,2,3];
a.join= a.shift;
//a.toString = a.shift;

//方案3：利用数据劫持   Object.defineProperty / Proxy
//获取a,如果a不是变量就是window的一个属性
let i = 0;
Object.defineProperty(window,'a',{
    get(){
        return ++i;
    }
})
```

No10:

```javascript
let utils = (function(){
    /*
     * toArray：转换为数组的方法
     *   @params   不固定数量，不固定类型
     *   @return   [Array] 返回的处理后的新数组
     */
    function toArray(){
        //=>实现你的代码（多种办法实现）   
    }

    return {
        toArray
    };
})();
let ary = utils.toArray(10,20,30); //=>[10,20,30]
ary = utils.toArray('A',10,20,30); //=>['A',10,20,30]
```

答题：

**arguments是实参集合，获取的结果是类数组（箭头函数中没有arguments），不能直接调取数组的方法（不是Array的实例）；**

```javascript
//剩余运算符
function toArray(...args){
     return args;
    //return [...arguments];   
    //return Array.from(arguments);
}

//兼容写法
function toArray(){
    //把类数组转换为数组
    var arr = [];
    for(var i=0;i<arguments.length;i++){
        arr.push(arguments[i])
    }
    return arr;
}
```

数组原型上有个slice方法，可发现实际与上面方法一实现类似，只是一个操作this，一个arguments，那么可以通过调取slice，通过改变this的指向为argumens就可以实现。

>  原理：只要把slice执行，让方法中this变为arguments，就可以实现把类数组转换为数组
>     		1.slice执行 => Array.prototype.slice()  或者  [].slice()
>     		2.把this改变为arguments   [].slice.call(arguments)
>     		前提：操作数组的代码(内置方法中的代码)需要适配改变的this(类数组)

```javascript
//只要两个实例结构类似，那么大部分操作他们的代码都可以共用，无外乎就是this指向问题
function toArray(){
	return [].slice.call(arguments);
}
```

No11：对象(数组)的深克隆和浅克隆

```javascript
//=>浅克隆：只复制对象或者数组的第一级内容
//=>深克隆：克隆后数组的每一级都和原始数组没有关联
//那么请说出，浅克隆都怎么去实现，如何实现深度克隆
let obj = {
    a: 100,
    b: [10, 20, 30],
    c: {
        x: 10
    },
    d: /^\d+$/
};

let arr = [10, [100, 200], {
    x: 10,
    y: 20
}];
```

答题：

```javascript
克隆，内存地址是不一样的。
/*
	实现对象的克隆方法：
		1.Object.assign:浅克隆
		2.{...obj}：展开运算符，也只能展开第一级，也是浅克隆
*/
let newObj = Object.assign({},obj);    
let newObj = {...obj};  
let newObj = obj; //=>不是克隆，只是赋值

/*
	实现数组的克隆方法：
	slice/concat-----浅克隆
	forEach/map/reduce-----遍历也只是遍历第一级
*/
let newArr = arr.slice();
let newArr = arr.concat([]);


深克隆：JSON.parse(JSON.stringify(arr));
//原理：暴力法——把原始数据直接变为字符串，再把字符串变为对象(此时浏览器重新开辟所有的内存空间),实现出深度克隆/深拷贝
//缺点：正则会变为空对象/函数直接消失/日期直接变为字符串/Symbol直接消失/BigInt直接报错/undefined直接消失
```

![](/img/blog/js/深浅克隆.png)

自己实现一个深克隆/深拷贝：

```javascript
function cloneDeep(obj){
    const constructor = obj.constructor;
    if(obj===null) return null;
    if(typeof obj !== 'object') return obj;  //基本类型处理
    if(/^(RegExp|Date)$/i.test(constructor.name))  return new constructor(obj);
    let clone  = new constructor();
    for(let key in obj){
        if(!obj.hasOwnProperty(key)) break;
        clone[key] = cloneDeep(obj[key])
    }
    return clone;
}
```

No12：已知基于 instanceof 可以实现检测：实例是否属于某个类，现在需要自己编写这样的一个方法，实现出 instanceof 的效果

```javascript
//=>example：要检测的实例
//=>classFunc:要检测的类
function instance_of(example, classFunc) {
    //...
}
let res = instance_of([12,23],Array);
console.log(res); //=>true
```

答题：

```javascript
//实例是否属于类，主要通过:  实例.__proto__ === 类.prototype
//example.__proto__ === classFunc.prototype

function instance_of(example,classFunc){
    let prototypeObj = classFunc.prototype,
        //proto = example.__proto__;  兼容问题
        proto = Object.getPrototypeOf(example);   //获取实例的原型：Object.getPrototypeOf()
    while(true){
        if(proto === null){   //找到了Object.prototype.__proto__
            return false;
        }
        if(proto === prototypeObj){   //在当前实例的原型链上找到了当前类
            return true;
        }
        //proto = proto.__proto__;
        proto = Object.getPrototypeOf(proto);
    }
}


//Function.prototype ---->  Symbol.hasInstance
//浏览器内部其实是基于Symbol.hasInstance检测的
```



附加题：

No1:

```javascript
//=>编写toType方法，实现数据类型检测
function toType( obj ) {
   //完成你的代码
}
console.log(toType(1)); //=>"number"
console.log(toType(NaN)); //=>"number"
console.log(toType([])); //=>"array"
console.log(toType(/^\d+$/)); //=>"regexp"
console.log(toType({})); //=>"object"
...
```

答题：

数据类型检测：typeof  /  instanceof / constructor / Object.prototype.toString()

typeof：null  /  数组  / 正则 / 日期 / 对象 => object

instanceof ：检测当前实例是否属于这个类，也可以用来检测数据类型，可以理解为对typeof的补充。但是不能用来处理基本数据类型，基本数据类型基于构造函数方式创建的实例是可以的。只要出现在实例的原型链上的类，检测结果都是true（页面中可以手动更改原型链的指向，因此导致检测结果不一定准确）。

```javascript
console.log(1 instanceof Number);   //false
consoel.log(new Number(1) instanceof Number); //true
```

constructor：同样可以被更改，检测结果不一定准确。可以处理基本数据类型。

```javascript
[].constructor === Array;   //true
(1).constructor === Number;  //true
[].constructor === Object; //false
```

Object.prototype.toString()：其它类的原型上的toString基本都是用来转换字符串的，只有Object原型上的toString是检测数据类型的，返回结果"[object  所属类]"。Object.prototype.toString执行，this是谁检测的就是谁的数据类型；该方法很强大，基本没有缺点。

```javascript
Object.prototype.toString.call(xxx);
或
({}).toString.call(xxx);


console.log(Object.prototype.toString.call(1));   //'[object Number]'
console.log(Object.prototype.toString.call(Array));   //'[object Function]'
...
```



```javascript
//正则 + Object.prototype.toString处理
function toType(obj){
    let type = Object.prototype.toString.call(obj);
    return /^\[\object ([a-z]+)\]\$/i.exec(type)[1].toLowerCase();  
}

//基于jQ的类型检测
//类型映射表
var typeArr = ['Boolean','Number','String','Function','Array','Date','RegExp','Object','Error','Symbol'];
typeArr.forEach(name=>{
    class2type["[object" + name + "]"] = name.toLowerCase();
})
//[object Boolean]:'boolean',
//[object Number]:'number',
//...

function toType(obj){
    //undefined 或 null
    if(obj == null){
        return obj + '';
    }
    //基本数据类型基于typeof处理，引用数据类型基于Object.prototype.toString处理
    //typeof new Number(10) => 'object' 但是基于这个方法检测出来的是'number'，所以映射表中也有基本数据类型的映射
    return typeof obj === 'object' || typeof obj === 'function' ? 
        class2type[toString.call(obj)] || "object" :     //映射表中找不到为'object'
    	typeof obj;
}
```



No2:

```javascript
~function(){
    function change(){
        //=>实现你的代码
    };
    Function.prototype.change=change;
}();
let obj = {name:'zhufeng'};
function func(x,y){
    this.total=x+y;
    return this;
}
let res = func.change(obj,100,200);
//res => {name:'zhufeng',total:300}
```

```javascript
fn.call(obj,10,20);
//1.fn先基于__proto__找到Function.prototype.call，并且让call方法执行;
//2.在call方法执行过程中【call中this->fn】,把fn执行，并且让fn中的this变为传递的第一个参数obj,在把10，20当作实参传递给fn，最后接收执行的返回值，把返回值作为call方法的返回值返回。
```

题目中change方法就类似是call方法的实现，那么如何手写一个call方法？

模拟内置基于C++完成的call方法：

```javascript
/* 
 * 1.改变fn中的this指向为obj => obj.fn() => 需要保证fn函数作为obj某个成员的属性值
 * 2.obj.fn = fn;  
 *   思路:把函数作为要改变的this对象的一个成员，然后基于对象的成员访问执行函数即可。
 * 	 obj.fn()执行
 * 3.参数处理
 */
Function.prototype.call = function call(context,...params){
    //context -> 最后要改变的函数中的this指向 obj
    //params -> 最后要传递给函数的实参信息 [10,20]
    //this -> 要处理的函数 fn
    
    //context为null或者undefined为window，否则传了什么就是什么
    context = context == null ? window : context;    
    
    //必须要保证context是一个对象
    let contextType = typeof context;
    if(!/^(object|function)$/i.test(contextType)){
        // context.constructor:当前值所属的类
        // context = new context.constructor(context); //Symbol/BigInt不能被new
        context = Object(context);
    }
    
    let result,key = Symbol('KEY');
    context[key] = this;  //把函数作为对象的某个成员值(成员名唯一，防止修改原始对象的值)
    result = context[key](...params);   //基于对象[成员]方式把函数执行，此时函数中的this就是对象
    delete context[key];  //设置的成员用完后删除掉
    return result;  //把函数的返回值作为call方法执行的结果返回
}
```

No3:

```javascript
~function(){
    //=>bind方法在IE6~8中不兼容，接下来我们自己基于原生JS实现这个方法
    function bind(){

    };
    Function.prototype.bind=bind;
}();
var obj = {name:'hello'};
function func(){
    console.log(this,arguments);
    //=>当点击BODY的时候，执行func方法，输出：obj [100,200,MouseEvent事件对象]
}
document.body.onclick = func.bind(obj,100,200);
```

答题：

```javascript
function bind(context,...params){
    //this -> 要处理的函数  func
    //context -> 要改变的函数中的this指向  obj
    //params -> 最后给函数传递的实参  [100,200]
    let _this = this;
    return function anonymous(...args){
        //args -> 可能传递的事件对象等信息
        //this -> 匿名函数中的this是由当初绑定的位置触发决定的，总之不是func要处理的函数
        _this.call(context,...params.concat(args));
    }
}
```

No:4

```javascript
var name = 'hello';
function A(x,y){
    var res=x+y;
    console.log(res,this.name);
}
function B(x,y){
    var res=x-y;
    console.log(res,this.name);
}
B.call(A,40,30);
B.call.call.call(A,20,10);
Function.prototype.call(A,60,50);
Function.prototype.call.call.call(A,80,70);
```

输出结果：

10     'A'

NaN   undefined

NaN  undefined

答题思路：

```javascript
B.call(A,40,30);   
/*找到call方法把它执行，再执行过程中：
  this->B    context->A   params->[40,30]
  A.xxx = B
  B执行，this指向为A   B执行输出res=40-30=10,this.name = 'A'
*/

B.call.call.call(A,20,10);   
/* 最后一个call执行
   this->B.call.call(call方法)    context -> A   params -> [20,10]
   A.xxx = call方法    
   A.xxx执行=>call方法执行: this->A   context->20->new Number(20)--基本类型值   params->[10]
   (20).xxx = A   
   (20).xxx(10)执行：=> A(10) => this为(20)，传参10 => x:10  y:undefined => NaN   
   new Number(20).name = undefined
*/

Function.prototype.call(A,60,50);
/*	把call方法执行
	this->Function.prototype   context->A   params->[60,50]
	A.xxx = Function.prototype
	A.xxx(60,50) => Function.prototype执行，this->A,传参60,50
	Function.prototype是匿名空函数，执行时啥都没干
*/

Function.prototype.call.call.call(A,80,70);
/* 最后一个call执行
   this-> Function.prototype.call.call(call方法)   context->A  params->[80,70]
   A.xxx = Function.prototype.call.call
*/
```



总结：

```javascript
B.call(A,40,30); 
```

一个call：最后执行的是前面的B，并且B中的this变为A，剩下的40和30传递给B；

```javascript
B.call.call.call.call(A,40,30); 
```

多个call（不管有多少个都一样）：

B.call.call....call(A，40，30)跟B没啥关系，是B作为实例找到的call方法；

第一次最后一个call执行：this->A  传递参数40和30；

第二次执行call：类似于A.call(40，30)  => 执行的是A，this->40，传参30

自我总结：一个call执行call前面的方法，多个call执行()中的方法，Function.prototype.call不执行，多个call执行call方法，最后结果NaN  undefined



### 深度比较

基本数据类型：基于 === 比较；

函数：都转换为字符串再进行比较；

对象：

- ​	正则/日期——都转换为字符串再进行比较；
- ​	普通对象/数组对象等——先比较私有属性的个数；如果个数相同，分别遍历每个属性，看看属性值是否一致；

```javascript
function compare(val1,val2){
    //因为typeof null => object，需要排除null情况
    let type1 = val1 === null ? 'null' : typeof val1,
        type2 = val1 === null ? 'null' : typeof val2,
    //函数的比较
    if(type1 === 'function' && type2 === 'function'){
        return val1.toString() === val2.toString();
    }
    //对象的比较
    if(type1 === 'object' && type2 === 'object'){
        //正则或者日期
        let constructor1 = val1.constructor,
            constructor2 = val2.constructor;
        if((constructor1 === RegExp && constructor2 === RegExp)||(constructor1 == Date && constructor2 == Date)){
            return val1.toString() === val2.toString();
        }
        //其它对象    
        let keys1 = Object.keys(val1),
            keys2 = Object.keys(val2);
         //先比较个数
        if(keys1.length !== keys2.length) return false;
        for(let i = 0; i < keys1.length; i++){
            let key1 = keys1[i],
                key2 = keys2[i];
            //比较key
            if(key1 !== key2) return false;
            let value1 = val1[key1],
                value2 = val2[key2];
            //比较相同key的值
            let flag = compare(value1,value2);   //判断值是否相等，递归调用比较方法
         	if(!flag) return false;   
        }
        return true;
    }
    //基本数据类型比较
    return val1 === val2;   
}
```

