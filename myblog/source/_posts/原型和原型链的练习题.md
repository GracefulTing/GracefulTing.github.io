No1:

```javascript
function fun(){
    this.a=0;
    this.b=function(){
        alert(this.a);
    }
}
fun.prototype={
    b:function(){
        this.a=20;
        alert(this.a);
    },
    c:function(){
        this.a=30;
        alert(this.a)
    }
}
var my_fun=new fun();
my_fun.b();
my_fun.c();
```

输出结果：alert弹出0    alert弹出30   

答题思路：

```javascript
1.fun---函数---堆内存
	“代码字符串”
    prototype（函数都天生自带一个prototype属性，属性值是个对象---堆内存）----A
2.func.prototype------每一个原型对象都有一个constructor函数----B
  	constructor：fun
    __proto__
3.fun.prototype={
    ...   //类原型重定向-----见下面详细解析
    /*--------------------新创建对象(堆) C,然后A指向C-----------------------
    	b:function(){}
    	c:function(){}
    	__proto__ ---------->  指向Object.prototype
    */
  }
/*---------------------------------类原型重定向--------------------------
  a.重新定向的对象中没有constructor;
  b.原始的原型对象上存放的属性方法不会存储到新重定向的对象上，因此实例不能再用原始的方法;
  c.原始的原型对象不被占用，堆内存释放;
  d.内置类的原型对象不允许重定向;
*/
4.var my_fun=new fun(); ----创建实例，并把函数执行【按照普通函数执行，且this指向实例】
  	a:0
    b:function(){...}
    __proto__  ------------>  C
5.my_fun.b() ———— b为私有，this指向my_fun,所以alert输出'0'
6.my_fun.c() ———— c为原型上的方法，this指向my_fun,所以alert输出'30'                   
```



向内置的原型上扩展方法：

```javascript
function Func(){
    
}

//方法太多时，一个个处理比较麻烦;
Func.prototype.A = function(){};
Func.prototype.B = function(){};
...
```



一般想往原型上批量设置属性方法，都是基于***重定向***方式，存在的问题：

- 缺失了constructor；
- 缺失了原始原型对象上的属性和方法；

```javascript
//重定向
Func.prototype = {
    A:function(){},
    B:function(){}
}
```



**解决批量扩展问题的方法**：

- 手动设置constructor

  ```
  Func.prototype = {
  	constructor:Func,
  	A:function(){},
      B:function(){}
  }
  ```

- 两个原型对象合并，用新的原型对象替换原始的原型对象（问题：如果新老属性方法相同，新值会替换旧值）

  ```javascript
  Func.prototype.test = function(){}  //原有的
  Func.prototype = Object.assign(Func.prototype,{
      A:function(){},
      B:function(){}
  })
  
  let f = new Func;
  console.log(f)
  ```

- 把老的原型对象作为新原型对象的上级原型（推荐使用）

  ```javascript
  let newProto = Object.create(Func.prototype);   //创建空对象，原型链指向老对象Func.prototype
  newProto = Object.assign(newProto,{
      A:function(){},
      B:function(){}
  })
  Func.prototype = newProto;
  ```

No2:

```javascript
function C1(name) {
    if (name) {
        this.name = name;
    }
}
function C2(name) {
    this.name = name;
}
function C3(name) {
    this.name = name || 'join';
}
C1.prototype.name = 'Tom';
C2.prototype.name = 'Tom';
C3.prototype.name = 'Tom';
alert((new C1().name) + (new C2().name) + (new C3().name));
```

输出结果：'Tomundefinedjoin'

答题思路：

```javascript
1.C1,C2,C3各开辟堆内存A1/A2/A3，有自己的prototype，并指向堆内存B1/B2/B3，堆内存B中有各自的constructor函数
2.B1,B2,B3都新增了name属性，value为'Tom'
3.new C1().name  =>  if判断没有执行，没有设置私有属性，找原型 => 'Tom'
4.new C2().name  =>  执行this.name=name=undefined => 'undefined'
5.new C3().name  =>  执行this.name=name=undefined || 'join' = 'join'
6.输出'Tomundefinedjoin'
```

No3:

```javascript
function Fn() {
    let a = 1;
    this.a = a;
}
Fn.prototype.say = function () {
    this.a = 2;
}
Fn.prototype = new Fn;
let f1 = new Fn;

Fn.prototype.b = function () {
    this.a = 3;
};
console.log(f1.a);
console.log(f1.prototype);
console.log(f1.b);
console.log(f1.hasOwnProperty('b'));
console.log('b' in f1);
console.log(f1.constructor == Fn);
```

输出结果：1    undefined    f(){this.a=3}    false   true   true

答题思路：

```javascript
1.Fn---函数---堆内存
	“代码字符串”
     prototype属性-------对象 【一开始指向A,执行完3指向B,此时B指向A】
2.prototype对象--堆内存---A
	constructor:Fn
	say:function(){...}
	__proto__  ------> Object.prototype
3.Fn.prototype = new Fn;   【原型重定向】
  new Fn---堆---B：
  	a:1【let为私有变量，this.xxx才是私有属性】
    b:function(){...} -----------【执行完5后新增】
	__proto__  ---->  Fn.prototype
4.let f1 = new Fn;   创建实例f1
  f1---堆内存---C
  	a:1
	__proto__  ----> 指向B
5.B中新增b属性
6.console.log(f1.a);  =>  this指向f1,f1.a = 1;   //1
  console.log(f1.prototype);  => 对象无该属性，只有函数有该属性  //undefined
  console.log(f1.b); => b不是f1私有的，__proto__向上查找  // f(){this.a = 3}
  console.log(f1.hasOwnProperty('b'));    非私有   //false
  console.log('b' in f1); => 检测b是否为f1的属性，不论公有私有都可以检测到   //true
  console.log(f1.constructor == Fn);  => 向上查找，直到找到A中 //true
```

No4:

```javascript
function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
}

Foo.getName = function () {
    console.log(2);
};

Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
function getName() {
    console.log(5);
}
Foo.getName();  
getName();  
Foo().getName();  
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
```

输出结果：2  4  1  1   2   3   3

答题思路：

```javascript
/*****************************考察点：函数的三种角色 & 运算符优先级********************************/

1.变量提升：
  function Foo(){...} ------ 堆 AF1 ---- 原型指向等一系列操作
  	Foo类---AF1:
    	“代码字符串”
        prototype ----> A
        getName:function(){console.log(2)}   ------【2.2执行新增该属性】
    Foo.prototype---A:
    	constructor:Foo
         getName:function () {console.log(3);}    -------【2.3执行新增该属性】
         __proto__   ----->  Object.prototype
  var getName;
  function getName(){...} ----- 堆 AF2(输出5的函数) ---- 原型指向等一系列操作
  	getName---AF2:
         “代码字符串”
         prototype -----> B
    getName.prototype---B:
         constructor:getName
         __proto__  -----> Object.prototype
   => 执行完2.4之后全局getName-----堆 AF3(输出4的函数)
2.代码执行：
  2.1 function Foo(){...}   //不处理
  2.2 Foo.getName = function () {console.log(2);}   //把Foo当作普通对象，新增getName属性
  2.3 Foo.prototype.getName = function () {console.log(3);}  //作为构造函数：原型上设置实例调取的公有方法
  2.4 var getName = function () {console.log(4);}   //全局getName由AF2---> AF3(输出4的函数)
  2.5 function getName() {console.log(5);}   //不处理
                 
  Foo.getName();  //Foo对象，访问对象成员   => 2
  getName();   //全局getName执行  =>  4    
  /*var和function不存在谁优先级高低问题，按照变量提升处理即可。
    比如var a=2;function a(){};
    变量提升：var a;function a(){}------------X
    代码执行：a=2;
  */
  Foo().getName();   //把Foo当作普通函数执行，执行返回结果调用getName => Foo执行，getName不是私有变量，找全局，于是把全局getName变为输出函数1的函数 => this指向window => 1
  getName();   //此时，全局getName为输出1的函数  => 执行全局getName => 1
            
/*--------------运算符优先级------------------
    成员访问 obj.xxx------19    
    带参数列表new    new Fn() ------ 19
    不带参数列表new   new Fn --------18
    相同优先级，从左到右运算;不同优先级，优先级大的先执行;
*/            
 //【new：当作普通函数执行，创建实例】
 new Foo.getName();   //先Foo.getName(),后new => 2
 new Foo().getName();  //先new Foo(),后getName() => 3
 new new Foo().getName();  //先let a = new Foo(),再a.getName(),最后new a => 3
```

No5:

```javascript
let n = 10;
let m = n.plus(10).minus(5);
console.log(m);  //=>15（10+10-5）
```

答题：

```javascript
题目是想需要在原型上扩展一个plus实现相加功能和minus实现相减功能;

在Number上扩展了方法,this指向创建的实例n
Number.prototype.plus = function plus(arg){
    return  this + arg; 
}

Number.prototype.minus = function minus(arg){
    return this - arg;
}

let n = 10;
console.log(n.plus(5))    //15
console.log(n.minus(3))   //7
console.log(n.plus(5).minus(3));  //12
```

No6:

```javascript
/*
 * 编写queryURLParams方法实现如下的效果（至少两种方案）
 */
let url="http://www.zhufengpeixun.cn/?lx=1&from=wx#video";
console.log(url.queryURLParams("from")); //=>"wx"
console.log(url.queryURLParams("_HASH")); //=>"video"
```

答题：

```javascript
String.prototype.queryURLParams = function queryURLParams(param){
    if(param==null) return this;
    if(param == '_HASH')  return this.split('#')[1];
    return this.split(param)[1].substring(1);  //说明：只会做到这里了
}
```

No7：基于ES6中的class重构下面的代码

```javascript
function Modal(x,y){
    this.x=x;
    this.y=y;
}
Modal.prototype.z=10;
Modal.prototype.getX=function(){
    console.log(this.x);
}
Modal.prototype.getY=function(){
    console.log(this.y);
}
Modal.n=200;
Modal.setNumber=function(n){
    this.n=n;
};
let m = new Model(10,20);
```

答题：



No8:

```javascript
let obj = {
    2: 3,
    3: 4,
    length: 2,
    push: Array.prototype.push
}
obj.push(1);
obj.push(2);
console.log(obj);
```

输出结果：{2:1,3:2,length:4,push:f(){...}}

答题思路：

```javascript
//主要考察Array.prototype.push的实现

很明显，push方法实现是下面的过程
Array.prototype.push = function A(val) {
　　　this[this.length] = val;
　　  // =>this.length 在原来的基础上加1
　　　return this.length;
}

obj.push(1); => this指向obj => obj[obj.length] => obj[2] = 1;   length:3
obj.push(2); => this指向obj => obj[obj.length] => obj[3] = 2;   length:4
console.log(obj);  //obj:{2:1,3:2,length:4,push:f(){...}}
```

No9：a等于什么值会让下面条件成立

```javascript
var a = ?;
if (a == 1 && a == 2 && a == 3) {
    console.log('OK');
}
```

答题：

```javascript
//方案1：借助对象转换为数字需要先转换为字符串，重写toString方法
var a = {
	i:1,
	toString:function(){
		return a.i++;
	}
}

//方案2：重写数组.join方法为shift方法，拿到每次shift的值
var a = [1,2,3];
a.join = a.shift;
```

No10:

```javascript
let utils = (function(){
    /*
     * toArray：转换为数组的方法
     *   @params   不固定数量，不固定类型
     *   @return   [Array] 返回的处理后的新数组
     */
    function toArray(){
        //=>实现你的代码（多种办法实现）   
    }

    return {
        toArray
    };
})();
let ary = utils.toArray(10,20,30); //=>[10,20,30]
ary = utils.toArray('A',10,20,30); //=>['A',10,20,30]
```

答题：

```javascript
function toArray(...args){
     return [...args];
}
```

No11：对象(数组)的深克隆和浅克隆

```javascript
//=>浅克隆：只复制对象或者数组的第一级内容
//=>深克隆：克隆后数组的每一级都和原始数组没有关联
//那么请说出，浅克隆都怎么去实现，如何实现深度克隆
let obj = {
    a: 100,
    b: [10, 20, 30],
    c: {
        x: 10
    },
    d: /^\d+$/
};

let arr = [10, [100, 200], {
    x: 10,
    y: 20
}];
```

答题：

```javascript
//浅克隆
function clone(a){
    if(Array.isArray(a)){
        let newObj = [];
        a.forEach((item,index)=>{
            newObj[index] = item;
        })
        return newObj;
    }else{
        let newObj = {};
        for(let key in a){
            newObj[key] = a[key]
        }
        return newObj;
    }
}

//深克隆
JSON.parse(JSON.stringify())

function deepClone(){
    if(Array.isArray(a)){
        let newObj = [];
        a.forEach((item,index)=>{
            if(/^object|function$/.test(typeof item)){
                deepClone(item);
            }
            newObj[index] = item;
        })
        return newObj;
    }else{
        let newObj = {};
        for(let key in a){
            if(/^object|function$/.test(typeof item)){
                deepClone(item);
            }
            newObj[key] = a[key]
        }
        return newObj;
    }
}
```

No12：已知基于 instanceof 可以实现检测：实例是否属于某个类，现在需要自己编写这样的一个方法，实现出 instanceof 的效果

```javascript
//=>example：要检测的实例
//=>classFunc:要检测的类
function instance_of(example, classFunc) {
    //...
}
let res = instance_of([12,23],Array);
console.log(res); //=>true
```

答题：





附加题：

No1:

```javascript
//=>编写toType方法，实现数据类型检测
function toType( obj ) {
   //完成你的代码
}
console.log(toType(1)); //=>"number"
console.log(toType(NaN)); //=>"number"
console.log(toType([])); //=>"array"
console.log(toType(/^\d+$/)); //=>"regexp"
console.log(toType({})); //=>"object"
...
```

答题：



No2:

```javascript
~function(){
    function change(){
        //=>实现你的代码
    };
    Function.prototype.change=change;
}();
let obj = {name:'zhufeng'};
function func(x,y){
    this.total=x+y;
    return this;
}
let res = func.change(obj,100,200);
//res => {name:'Alibaba',total:300}
```



No3:

```javascript
~function(){
    //=>bind方法在IE6~8中不兼容，接下来我们自己基于原生JS实现这个方法
    function bind(){

    };
    Function.prototype.bind=bind;
}();
var obj = {name:'zhufeng'};
function func(){
    console.log(this,arguments);
    //=>当点击BODY的时候，执行func方法，输出：obj [100,200,MouseEvent事件对象]
}
document.body.onclick = func.bind(obj,100,200);
```



No:4

```javascript
var name = '珠峰培训';
function A(x,y){
    var res=x+y;
    console.log(res,this.name);
}
function B(x,y){
    var res=x-y;
    console.log(res,this.name);
}
B.call(A,40,30);
B.call.call.call(A,20,10);
Function.prototype.call(A,60,50);
Function.prototype.call.call.call(A,80,70);
```

输出结果：

10     'A'

...  （不太会）

答题思路：

```javascript
B.call(A,40,30);   //B执行，通过call来改变this指向为A   B执行输出res=40-30=10,this.name = 'A'
```

