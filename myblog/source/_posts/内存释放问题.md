### 堆内存释放问题

创建一个引用类型值，就会产生一个堆内存。

如果当前创建的堆内存不被其他东西占用了，浏览器会在空闲时查找每一个内存的引用情况，不被占用的都会被回收释放掉。

```javascript
let obj = {
	age:18
}
let oop = obj;
```

此时obj和oop都占用了对象的堆内存，想要释放堆内存，需要手动解除变量盒值的关联（null——空对象指针）

```javascript
obj = null;
oop = null;
```

浏览器的垃圾回收机制：

1. 引用计数（以IE为主）：在某些情况下会导致计数混乱，这样会造成内存不能被释放（内存泄漏）

2. 检测引用（占用）（以谷歌为主）：浏览器在空闲时会依次检测所有的堆内存，把没有被任何事物占用的内存释放掉，以此优化内存。

   手动释放内存，其实就是解除占用，手动赋值为null即可。

### 栈内存释放问题

- 打开浏览器形成的全局作用域是栈内存；
- 手动执行函数形成的私有作用域是栈内存；
- 基于ES6中的let/const形成的块作用域也是栈内存；

全局栈内存：关掉页面的时候才会销毁；

私有栈内存：

1. ​	一般情况下，函数执行完成，形成的私有栈内存就会被销毁释放掉（排除出现无限递归、死循环模式）；

2. ​	但是一旦栈内存中的某个东西（一般都是堆地址）被私有作用域以外的事物给占用了，则当前栈内存不能被立即释放销毁（特点：私有作用域中的私有变量等信息也保留下来了）；

   市面上认为的闭包：函数执行形成不能被释放的私有栈内存才是闭包；

```javascript
//情况1
function fn(){
    ...         
}
fn();    //函数执行形成栈内存，执行完成栈内存销毁
    
//情况2
function x(){
    return function(){
        ...
    }
}
let f = x();    //f占用了x执行形成的栈内存中的一个堆地址，则x执行形成的栈内存不能被释放
```



