## 浏览器渲染过程

一个页面从服务器访问回来后，浏览器拿到页面源代码后做的事情：

1. 生成DOM TREE   =>   处理HTML

   - 基于HTTP获取的是流文件（进制编码）；    -----16进制

   - 把进制编码编译为具体的字符；   -----字符串

   - 按照Token进行解析（词法解析）；         -------startTag:html 等，此处token作为令牌，是词法解析的规则

   - 生成具体的节点（元素节点 / 文本节点...）；   -------标签

   - 按照相互嵌套的关系生成DOM树（节点树）；

2. 生成CSSOM TREE   =>  处理CSS

   - 同DOM TREE类似，只是一个处理HTML，一个处理CSS

3. 生成RENDER TREE（渲染树）；    

   - DOM TREE + CSSOM TREE  = RENDER TREE
   - 对于开始设置为display：none样式的元素是不会在渲染树中生成的（开始加载页面时这些元素不进行渲染）；

4. 布局 / 回流 / 重排 （Layout）；

   - 按照渲染树计算出每个元素在视口中的位置和大小；

5. 分层；    -----脱离文档流造成的，z-index层级（通过开发者工具 ------  More Tools ------ Layers）

   - 按照计算出来的样式进行分层；

     定位 / 设置透明度  RGBA / 设置滤镜 / 文本超过盒子大小时被裁切 

   - 单独计算每一层的绘制列表（具体怎么绘制）；

   ----------------------------------->以上的操作都是交给 "GUI渲染线程" 来完成的

6. 绘制 / 重绘（Painting）；

   - 把生成的绘制列表提交给 "合成线程"；

   - "合成线程" 进行最后绘制，呈现在浏览器的页面上；

1-5是GUI渲染线程完成，6是合成线程；





## 进程和线程

进程：一个程序（浏览器新建一个页卡就是一个进程）  【工厂】

线程：一个进程中可能会包含多个线程，每个线程同时可以做一件事情  【工人】



真正的同时做多件事情必须依赖多线程，浏览器是多线程的。

但是JS本身是单线程的，因为浏览器本身只分配一个线程 "GUI渲染线程" 运行JS代码；

JS从本质来讲是不能同时做多件事情的：

​	**同步**：上一件事情完成，再去做下一件事情；

​	**异步**：上一件事情没有完成，把它做一些特殊处理，下一件事情继续执行；【但是绝对不是JS可以同时处理两个事情】

浏览器生成DOM TREE / CSSOM TREE 的过程也是单线程的“GUI渲染线程”，会配合浏览器的多线程去完成一些事情，例如：资源请求利用的就是浏览器的HTTP网络线程去做的；



## 浏览器具体的解析过程 "GUI渲染线程"

1. 自上而下解析完所有HTML标签/各种节点后，DOM TREE就生成了；

2. 但是过程中还会遇到一些比较特殊的：	

   css

   - link：外链式 ，浏览器会分配一个新的HTTP网络线程去加载资源文件，不会阻碍DOM树的渲染 ；

   - style：内嵌式，不用去请求新的资源文件了，但是此时样式还没有处理，浏览器会做一个记录，它会等待所有的CSS资源加载回来之后按照先后顺序依次渲染CSS，从而生成CSSOM树；

   - import：导入式，虽然也是分配HTTP网络线程去加载资源文件，但是此时GUI渲染线程会被阻塞掉【阻碍DOM树渲染】，只有等资源加载回来后才会继续渲染DOM；

   js

   - 遇到script内嵌js代码的，会立即执行JS，阻碍DOM TREE的渲染；

   - 遇到script外链js代码的，会阻碍DOM TREE的渲染，同时分配一个HTTP线程去加载资源文件；资源文件加载回来后，立即执行JS；如果JS中没有采用异步，直接获取DOM元素而DOM元素此时还没有渲染，JS是获取不到的；

   img

   - 老版本浏览器会阻碍DOM渲染；
   - 新版本浏览器虽然不会阻碍DOM渲染，但是图片资源的请求会占用HTTP线程（浏览器同时只能开6~7个HTTP线程，这样图片/音视频资源加载本来就会慢，会影响其它资源link/script等的加载）；
   - 图片资源的渲染也是比一般资源耗时间的，也会拖累页面的渲染速度；

   -----------性能优化------------------

   CRP浏览器关键节点优化

   - 不用@import；

   - link放到Head中，尽可能提前加载资源我呢见，这样等DOM树渲染完后，资源可能也加载回来了；

   - 如果css代码比较少，尽可能使用内嵌式，可以减少HTTP请求；但是如果样式比较多，采用内嵌式，第一次加载HTML都会浪费很长时间，这样还不如基于link分开加载；移动端开发都是内嵌优先（当然也要考虑CSS代码量）。

   - 减少DOM或者减少DOM的层级嵌套，以及标签语义化...【开始只把首屏结构/内容写出来，渲染只是首屏的，当首屏加载完页面滚动的时候，再基于JS创建其它屏幕的结构和内容 => 骨架屏/SSR】

     [客户端骨架屏，开始首屏结构都没有，只有一个loading或者占位图而已]

   - 把script放到页面底部（先渲染DOM TREE，再执行JS也可以获取到DOM元素了），也可以基于事件DOMContentLoaded / load等到结构加载完成再去获取DOM元素；

   - async / defer给script设置的属性，async是开辟HTTP线程加载资源文件，此时DOM TREE继续，但是资源文件一旦加载回来停止DOM TREE，先执行JS代码（不考虑JS引入顺序，谁先加载回来谁先执行），defer也是开辟HTTP线程加载资源文件，即使资源文件加载回来，也会等待DOM TREE渲染完，然后按照JS的导入顺序依次执行JS（不兼容低版本浏览器）；
   - 图片合并（css  sprite）/ base64 / iconfont(css绘制) / svg / 图片懒加载

   ```javascript
   window.onload = function(){
       //触发条件：所有资源都加载完成（包含DOM TREE / CSS / 图片等资源）
   }
   
   window.addEventListener('DOMContentLoaded',function(){
       //触发条件：DOM TREE加载完成即可
   })
   
   setTimeout(()=>{
       //...
   },0)
   
   上面三个执行顺序：DOMContentLoaded > onload，定时器设置0优先级1
   ```

   

​	



1. 浏览器渲染过程

   首先要从服务器获取需要渲染的内容，此时获取到的是文件流（进制编码内容），那么接下来浏览器会把16进制字节信息编译为代码字符串，然后按照W3C规则进行字符解析生成对应的tokens，再转换成浏览器内核可以识别渲染的DOM节点，最后再按照节点解析为对应的DOM树和CSSOM树。

   ![](/img/blog/render/all.png)

   （1）在CSS资源还没有请求回来之前，先生成DOM树（DOM的层级关系以及节点关系）；

      => 该过程中如果遇到JS先把JS执行

   ​		正常情况下JS会阻碍GUI渲染，所以JS一般放在页面尾部，就是为了确保DOM树生成完才会加载JS；

   ​		也可能会与defer和async异步管控JS请求；

   （2）当所有CSS请求回来之后，浏览器按照CSS导入顺序依次进行渲染，最后生成CSSOM树；

   （3）把DOM树和CSSOM树结合在一起，生成有样式有结构的RENDER TREE 渲染树；

   （4）浏览器按照渲染树在页面中进行渲染和解析；

   - 布局（Layout）或回流/重排（reflow）—— 计算元素在设备视口中的大小和位置；
   - 绘制/重绘（painting）—— 根据渲染树以及回流得到的几何信息，得到节点的绝对像素；

2. link、@import引入的区别

   link和@import都是导入外部样式（服务器获取样式文件），区别如下：

   ```html
   //link
   <link href="css/style.css" rel="stylesheet" type="text/css"></link>
   
   //import
   @import ...;
   ```

   - link——GUI渲染不会停止，浏览器会派发新的线程（HTTP线程）去加载资源文件，无论CSS是否请求回来，代码继续渲染；

   - @import——GUI渲染暂时停止渲染，去服务器加载资源文件，请求没有返回之前是不会继续渲染的；

   - 如果是嵌入式style，GUI直接渲染；

3. script标签中defer和async有什么区别

   script会阻碍GUI渲染，先请求js（http线程），在把请求回来的执行，只有js执行完再去GUI渲染；

   defer：GUI继续渲染，同时http去请求，请求回来也不会立即执行，而是等到GUI渲染完再去按照之前引入的script顺序依次执行。  可以理解为老板给各个员工分配工作任务，给A分配完A就去执行，老板继续给别的员工分配，即使A做完也要等到老板全部分配完任务之后再报告，然后依次验收工作成果。

   async：GUI继续渲染，同时http去请求，当请求回来后立即先执行js，GUI暂停，js执行完之后GUI继续。谁先回来谁执行（适用于没有依赖顺序的）。可以理解为老板给A分配完任务之后就看着A去执行任务，等到A做完才分配B做。

   用图来说明一下更加容易理解：

   ![](/img/blog/render/script.png)

   link不会阻碍GUI渲染，GUI继续向下，link会开启一个新的http线程去加载css代码；

4. 性能优化（基于渲染机制优化）

   ```
   1、减少DOM树渲染时间（HTML层级不要太深，标签语义化）；
   2、减少CSSOM树渲染时间（选择器从右向左解析，尽可能减少选择器层级）；
   3、减少HTTP请求次数和请求大小；
   4、一般会把CSS放在页面的开始位置（提前请求资源，用link不用import，对于移动断如果css较少尽可能使用嵌入式）；
   5、避免白屏，可快速生成loading渲染树（前端骨架屏）；
   6、服务器的SSR骨架屏所提高的渲染是避免了客户端再次单独请求数据，而不是样式和结构上的首屏处理；
   7、把JS放在页面底部以及尽可能使用defer或者async；
   8、CRP性能节点优化；
   ```

5. 预处理机制：预先把所有请求资源在GUI渲染之前就去发送请求，http并发限制（6-7）；

6. 回流(重排)和重绘

   **回流/重排**——元素位置/大小/页面布局和几何信息变化，触发重新布局，导致渲染树重新计算布局和渲染，例：元素位置（移动）、尺寸（width/height/padding/margin/border）、内容发生变化等，页面一开始渲染时（无法避免，因为回流根据视口大小来计算元素位置和大小，浏览器窗口尺寸变化也会引发回流）；

   

   **重绘**——元素样式改变（宽高、大小、位置不变），eg：outline、color、background-color、visibility等；

   回流比重绘更耗费性能。

   

   ***注：回流一定会触发重绘，重绘不一定会回流。***

```javascript
box.onclick=function(){
	//这两行修改操作只引发一次回流
	box.style.width = "200px";
	box.style.height = "200px";
}

box.onclick=function(){
	//引发两次回流，因为一旦遇到获取样式的代码需要把之前队列中的样式进行渲染
	box.style.width = "200px";
    console.log(box.offsetWidth);
	box.style.height = "200px";
}
```

**浏览器渲染队列机制**：遇到修改样式代码，浏览器没有立即渲染，而是先把它放到渲染队列中，继续看下面是否还是修改样式的，是的话继续放进去......直到遇到获取元素样式的代码（盒子模型或者获取样式）或者没有修改样式的代码了，则把现有队列中的样式统一进行渲染（引发一次回流），继续向下执行代码...

避免回流重绘：

- ​	分离读写（获取和修改分开）；

  ```javascript
  box.style.left = "200px";
  box.style.top = "200px";
  
  box.offsetLeft;
  box.offsetTop;
  ```

- ​	缓存布局；

  ```javascript
  div.style.left = div.offsetLeft - 1 + 'px';
  =>
  //先获取值再使用
  var curLeft = div.offsetLeft;
  div.style.left = curLeft - 1 + 'px';
  ```

- ​	元素批量修改；

  ```javascript
  //文档碎片
  let frg = document.createDocumentFragment();
  for(let i=0;i<10;i++){
      let span = document.cereateElement('span');
      span.innerHTML = i;
      frg.appendChild(i);
  }
  document.body.appendChild(frg);   //创建文档碎片，引发一次回流

  
  //字符串拼接
  let str = ``;
  for(let i=0;i<5;i++){
      str += `<span>${i}</span>`
  }
  document.body.innerHTML = str;
  ```
  

- 动画操作或者样式的改变，如果操作的是具备 position:absolute/fixed 再或者具备 opacity/filters 等这些属性样式的元素上，则可以优化回流的速度（不是不回流，只是优化了回流的速度 => 因为拥有这些样式的元素，它们渲染的时候是分层渲染的，我们修改这些元素上的样式，在重新Layout和渲染的时候，只会对当前层进行重新处理）。


- 还有一个更优化的手段：transform，基于transform修改元素的样式，直接跳过Render Tree和Layout阶段，直接把更改的样式告诉 "合成线程" 去渲染，不会引发回流，只会重绘而已。    =>开启了渲染的硬件加速