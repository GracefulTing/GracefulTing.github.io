### 闭包

> 从性能角度讲，项目中应该减少对闭包的使用（因为闭包会产生不释放的栈内存，过多使用容易导致内存溢出或者降低性能）

> 作用：
>
> 1. 保护（私有变量和外界没有必然联系）
> 2. 保存（形成不销毁的栈内存，里面的私有变量等信息保存下来了）

1、JQuery -> 为了防止全局变量污染，JQ中的方法和变量需要用闭包保护起来。（导入jq后，它里面有大量的方法，如果不把这些方法保护起来，用户编写的方法很容易和jq方法名相同产生冲突，即全局变量污染）

```javascript
/*  *****  JQuery源码  ***** */
(function(global,factory){
    //area1
    ...  
    //typeof window !== 'undefined'?window:this   ->   验证当前所处环境的全局对象是window还是global等
    //factory -> function(window,noGlobal){}
    factory(global);  // -> 执行area2-function
})(typeof window !== 'undefined'?window:this,function(window,noGlobal){
    //area2
    ...
    var jQuery = function(){
        ...
    }
    
    //通过给全局对象增加属性，把私有jquery方法暴露到全局作用域下供外面使用(<=>等价于return  jQuery)
    //外面需要使用函数中的私有内容，可以基于window.xxx和return xxx两种方式实现。
    window.jQuery = window.$ = jQuery; 
});
    
/*  *****  使用  ***** */
jQuery();  //相当于window.jQuery()
或
$();
```

真实项目中，我们一般把自己写的内容放到一个闭包中，这样可以有效防止自己的代码和别人代码产生冲突（全局变量污染：真实项目中是尽可能减少对全局变量的使用的）；如果需要把自己的东西给别人用，基于return和window.xxx等方式暴露给别人即可。



2、基于let/const/class等创建变量，会把所在大括号（除对象的大括号之外）当作一个全新的私有块级作用域；

- 函数执行会产生私有的栈内存（作用域/执行上下文）
- let等也会产生私有的栈内存（var不会）



闭包练习题：

```javascript
var ary = [1,2,3,4];
function fn(ary){
    ary[0] = 0;
    ary = [0];
    ary[0] = 100;
    return ary;
}
var res = fn(ary);
console.log(ary);    //[0,2,3,4]
console.log(res);	 //[100]
```

解析：

```javascript
/*
	第一步：全局作用域-变量提升
	ary
	fn——AF0(堆内存，存储fn函数中的代码字符串)
	res
	第二步：代码执行
*/
var ary = [1,2,3,4];   //2.1赋值-引用数据类型-开辟堆内存AF1
//2.2变量提升阶段做处理
function fn(ary){
    /*
    	第三步：fn函数执行  传参ary，即AF1  形成私有作用域fn(AF1)
    	3.1——形参赋值，变量提升 ——> ary赋值AF1
    	3.2——代码执行
    		arr[0]=0;  AF1堆中的第一个元素值修改
    		ary = [0];  开辟新堆BF0,一个元素为0,修改ary对应的地址为BF0
    		ary[0] = 100;  修改BF0中元素为100
    		return ary;   -> return BF0;
    */
    ary[0] = 0;
    ary = [0];
    ary[0] = 100;
    return ary;
}   
var res = fn(ary);   //2.3-fn函数传实参，执行函数并将返回值赋给res    3.3-res值为BF0
console.log(ary);    //第四步：输出[0,2,3,4]
console.log(res);	 //第五步：输出[100]
```

```javascript
/*
	var test = 自执行函数执行的返回结果;
	1、自执行函数执行
		test = AF0(小函数);
*/
var test = (function(i){
    	/*
    		1.1 形参赋值，变量提升 ——  i=2
    		1.2 return AF0(小函数);
    	*/
    	return function(){
            //传递5无用，没有形参
            alert(i*=2);  //i=i*2,i找上级=> 2*2=4     => "4"
        }
})(2)
test(5);
```

```javascript
var a = 1;
var obj = {
    name:'tom'
}   //obj——AF0
function fn(){
    //形参赋值&变量提升  var a2;
    var a2 = a;  //a2 = 1;
    obj2 = obj;   //window.obj2 = AF0;  不是私有
    a2 = a;   //a2=1;
    obj2.name = 'jack';  //AF0堆中的name修改为jack
}
fn();
console.log(a)    //1
console.log(obj)  //{name:'jack'}
```

先形参赋值后变量提升

```javascript
var a = 1;
/*
	1、形参赋值    a=1
	2、变量提升  
		var a;(无效，因为已有形参a)
		function a... -> 堆BF0; (声明无效，但需要给a赋值为函数)
*/
function fn(a){
    console.log(a);   // 输出: 函数-f a() {}
    var a = 2;
    function a(){}
    console.log(a)    //2
}
fn(a);  //把全局a的值1当作实参传递给fn
```

```javascript
/*
	1.全局作用域
		1.1变量提升：a b A-AF0   
		1.2代码执行：a=0  b=0  A(1)执行
			2.2执行完之后，A改为BF0
*/
var a=0,b=0;
function A(a){
    /*
    	2.A(1)执行形成私有作用域AAA => AF0(1)
    		2.1形参赋值&变量提升   形参赋值a=1
    		2.2代码执行 A=BF0,开辟堆存储代码字符串   A是全局window.A
    		2.3 alert(a++); 弹出字符串"1"——先弹出a在累加  a=2
    	3.A(2)执行形成私有作用域BBB => BF0(2)
    		3.1形参赋值&变量提升 形参赋值b = 2;
    		3.2代码执行 
    			alert(a+b++); 弹出字符串"4"——先弹出4在累加 b=3
    			=>a+2  //a是上级作用域AAA中的 b是私有
    			=>b++
    */
    A = function(b){
        alert(a+b++);
    }
    alert(a++);
}
A(1);
A(2);
```

