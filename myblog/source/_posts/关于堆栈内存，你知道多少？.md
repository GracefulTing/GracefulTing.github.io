## 执行环境栈和执行上下文

编写的JS都需要在一个环境中运行：

1. 浏览器（引擎）
2. node（基于v8渲染js）
3. webview（v8引擎）
4. ......

**执行环境栈 ECStack（Execution Context Stack）**：浏览器想要执行JS代码，需要提供一个供代码执行的环境，该环境即为执行环境栈，又称 栈内存（从内存中分配出来的一块内存）

**执行上下文 EC（Execution Context）**：在编程语言中，代码执行中为了区分全局和函数执行所处的不同作用域，目的是为了区分每个词法作用域下代码的独立性，形成执行上下文 （代码执行所在的词法作用域，或者代码执行所处的范围）

在每一个上下文代码执行的时候，都可能会创建变量。所以在每一个上下文（无论是全局还是私有），都会有一个存储变量的空间；分别为：VO（Varibale Object）和 AO（Active Object）。

**变量对象**：存放当前上下文中的变量，只不过全局上下文称为VO(G)，私有上下文中称为AO(G)，但是也是变量对象；

**全局对象**：GO（Global object），跟VO/AO没有关系，浏览器把所有后期需要供JS调取使用的属性和方法（内置）都放在GO对象中，并且在全局中创建一个window变量指向它。全局对象方法有setInterval、eval、JSON....等

这么看，我们可以把执行环境栈理解为一个菜市场，那么市场中每个店面都是一个私有上下文，互相独立，各家卖各家的蔬菜水果。每家店中的蔬果都可以当作是AO中的对象。市场中的管理部门以及停车场都可以当作是全局执行上下文，白天卖菜就要进市场开门，代表了进栈执行，等到晚上关门，代表执行完出栈。个人觉得可以这样理解。

## 对象数据类型

对象数据类型：由0到多组键值对（属性名和属性值）组成的.

属性名的类型：
 * 		说法1：属性名类型只能是字符串或者Symbol
 * 		说法2：属性名类型可以是任何基本类型值，处理中可以和字符串互通(个人更认同说法2)
 * 		但是属性名绝对不能是引用数据类型，如果设置引用类型，最后也是转换为字符串处理的

obj[x] —— x为变量，把x变量存储的值当作属性名，获取对象的属性值 
obj['x'] —— 获取属性名为x的属性值  <=>  obj.x

```javascript
/*
 *		属性名为对象-----转为字符串'[object Object]'
 *		let x={
 *			0:0
 *		}
 *		let obj={};
 *		obj[x]=100; 
 *		console.log(obj);   //{'[object Object]':100}
 */

let x = 20;
let obj = {
    x:100
}
//属性名肯定是一个值
obj[x] ———— 把x变量存储的值当作属性名，获取对象的属性值 => obj[20] => undefined
obj['x']<=>obj.x ———— 获取属性名为x的属性值 => 100

//练习
var a = {},b='0',c=0;
a[b]='hello';  => a['0']='hello'
a[c]='world';  => a[0] = 'world'
console.log(a[b]);   //'world'

var a = {},b=Symbol('1'),c=Symbol('1');   //symbol唯一值，b!=c
a[b]='hello'; 
a[c]='world';
console.log(a[b]);   //'hello'

var a = {},b={n:'1'},c={m:'2'};  
a[b]='hello';  => a['[object Object]']='hello'
a[c]='world';  => a['[object Object]']='world'
console.log(a[b]);   //'world'
```

创建变量&赋值：

1. 创建一个值（基本类型值直接存储在栈内存中，引用数据类型值需要先开辟一个堆内存，把内存存储进去后，把堆内存地址存放到栈内存中供变量调用）；
2. 创建一个变量存储在变量对象中；（声明）
3. 让变量和值进行关联（指针指向的过程）；（定义）

```javascript
let a = 12,b = 13;   ===>  let a = 12;let b = 13;   

let a = b = 12;  //从右到左 1.创建值12  2.b=12   3.let a = 12

//成员访问a.x优先级很大，所以无论怎么调换位置都是先处理a.x={}
a.x = a = {}
a = a.x ={}

// a ----- AF0
var a = {
    n:1
}        
// b------ AF0
var b = a;
//a.x ----- AF1
// a ------ AF1
a.x = a = {
    n:2
}
console.log(a.x)   //undefined
console.log(b)     
/*
{
	n:1,
	x:{
		n:2
	}
}
*/
```



```javascript
var x = [12,23];
function fn(y){
    y[0] = 100;
    y = [100];
    y[1] = 200;
    console.log(y);   //[100,200]
}
fn(x);
console.log(x);  //[100,23]

/*
* 创建一个函数
* 1.开辟一个堆内存（16进制内存地址）
* 2.声明当前函数作用域（在哪个上下文中创建得，它得作用域就是谁）
* -.顺便标记形参（方便执行时看是否有形参）
* 3.把函数体中代码当作“字符串”存储在堆内存中（创建一个函数，存储得是一堆字符串，所以函数只要不执行，函数就没啥意义）
* 4.把函数堆地址类似于对象一样放到栈中供变量调用（函数名）
*/

/*
* 执行函数
* 1.会形成一个全新的私有上下文EC(XXX)（目的：供函数体代码执行），然后进栈执行
* 2.在私有上下文中有一个存放私有变量的变量对象AO(xxx)
* 3.在代码执行前：
* 	初始化它的作用域链 <自己的上下文,函数作用域>
*   初始化this（箭头函数没有this）
*	初始化arguments实参集合（箭头函数没有arguments）
* 	形参赋值（形参变量是函数的私有变量，需要存储在AO中）
*	变量提升（在私有上下文中声明的变量都是私有变量）
*	....
* 4.代码执行（把之前在函数堆中存储的字符串拿来在上下文中依次执行）
*	作用域链查找机制：在代码执行中，遇到一个变量首先看是否为私有变量，如果是私有变量，接下来所有操作都是操作私有的（和外界没有直接的练习）;如果不是自己私有的，则按照scoped-chain向上级上下文中查找（如果是上级的，接下来的操作都是操作上级上下文中的变量）,一直找，直到找到EC(G)为止。
* 5.根据实际情况确定当前上下文是否出栈释放
*	为保证栈内存大小（内存优化），一般情况下，如果当前函数执行产生的上下文，在进栈且代码执行完后，会把上下文移除栈（上下文释放，之前在上下文中存储的私有变量等信息也就跟着释放了） =>全局上下文是在打开页面生成的，也需要在关闭页面的时候释放掉（只有页面关闭才会被释放掉）
*	特殊情况：只要当前上下文中的某些内容被上下文以外的东西占用，那么当前上下文是不能被释放的（上下文中存储的变量等信息也保留下来了）  => 这种情况就是大家认为的闭包
*
*
* 函数第二次执行会形成一个全新的私有上下文，把之前做过的事情还是原封不动的再执行依次，此时形成的上下文和上一次形成的上下文没有必然联系
*/

//实参-值     形参-私有变量
```

